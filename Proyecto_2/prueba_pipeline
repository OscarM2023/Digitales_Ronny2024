$date
	Wed May 29 13:16:20 2024
$end

$version
	Synopsys VCS version R-2020.12-SP2_Full64
$end

$timescale
	1ns
$end

$comment Csum: 1 24c2bb43aa5e961b $end


$scope module z_pipeline_tb $end
$var reg 1 ! RST $end
$var reg 1 " CLK $end

$scope begin unnamed$$_0 $end
$upscope $end


$scope module pipeline_prueba $end
$var wire 1 # rst $end
$var wire 1 $ clk $end
$var wire 32 % pc_mux_to_pc [31:0] $end
$var wire 32 & pc_to_inst_mem [31:0] $end
$var wire 32 ' pc_adder_to_pc_mux [31:0] $end
$var wire 32 ( inst_mem_to_inst_pipe [31:0] $end
$var wire 32 ) instruction [31:0] $end
$var wire 32 * register_1 [31:0] $end
$var wire 32 + register_2 [31:0] $end
$var wire 1 , register_1_equals_register_2 $end
$var wire 32 - pipe_pc_passthrough [31:0] $end
$var wire 32 . imm_adder_to_pc_mux [31:0] $end
$var wire 32 / immediate_sexted [31:0] $end
$var wire 4 0 alu_operation [3:0] $end
$var wire 1 1 stall_signal_for_mux $end
$var reg 9 2 control_signals_to_be_muxed [8:0] $end
$var wire 1 3 control_pcsrc $end
$var wire 1 4 control_alusrc_to_mux $end
$var wire 1 5 control_memtoread_to_mux $end
$var wire 1 6 control_memwrite_to_mux $end
$var wire 1 7 control_memtoreg_to_mux $end
$var wire 1 8 control_regwrite_to_mux $end
$var wire 1 9 and_branch_was_taken $end
$var wire 1 : hazard_unit_stall_signal $end
$var wire 1 ; hazard_unit_pcwrite_signal $end
$var wire 9 < control_signals_from_mux [8:0] $end
$var reg 4 = mux_aluop_to_id_ex [3:0] $end
$var reg 1 > mux_alusrc_to_id_ex $end
$var reg 1 ? mux_memtoread_to_id_ex $end
$var reg 1 @ mux_memwrite_to_id_ex $end
$var reg 1 A mux_memtoreg_to_id_ex $end
$var reg 1 B mux_regwrite_to_id_ex $end
$var wire 4 C id_ex_aluop_to_alu [3:0] $end
$var wire 1 D id_ex_alusrc_to_alusrc_mux $end
$var wire 1 E id_ex_memtoread_to_hazards $end
$var wire 1 F id_ex_memwrite_to_ex_mem $end
$var wire 1 G id_ex_memtoreg_to_ex_mem $end
$var wire 1 H id_ex_regwrite_to_ex_mem $end
$var wire 32 I id_ex_rs1_to_forward_a_mux [31:0] $end
$var wire 32 J id_ex_rs2_to_forward_b_mux [31:0] $end
$var wire 5 K id_ex_a_rs1_to_forwarding [4:0] $end
$var wire 5 L id_ex_a_rs2_to_forwarding [4:0] $end
$var wire 5 M id_ex_a_rd_to_ex_mem [4:0] $end
$var wire 32 N id_ex_imm_sexted_to_alu_src_mux [31:0] $end
$var wire 32 O forward_a_mux_to_alu_a_in [31:0] $end
$var wire 32 P forward_b_mux_to_alu_src_mux [31:0] $end
$var wire 32 Q alu_src_mux_to_alu_b_in [31:0] $end
$var wire 32 R alu_out_to_ex_mem_pipe [31:0] $end
$var wire 2 S forwarding_forward_a_sel_signal [1:0] $end
$var wire 2 T forwarding_forward_b_sel_signal [1:0] $end
$var wire 1 U ex_mem_memwrite_to_data_mem $end
$var wire 1 V ex_mem_memtoreg_to_mem_wb $end
$var wire 1 W ex_mem_regwrite_to_mem_wb $end
$var wire 32 X ex_mem_result_op_to_data_mem [31:0] $end
$var wire 32 Y ex_mem_wr_data_to_data_mem [31:0] $end
$var wire 5 Z ex_mem_a_rd_to_mem_wb [4:0] $end
$var wire 32 [ data_mem_out_to_mem_wb [31:0] $end
$var wire 1 \ mem_wb_memtoreg_to_data_mem_skip_mux $end
$var wire 1 ] mem_wb_regwrite_to_registers $end
$var wire 32 ^ data_read_to_data_mem_skip_mux [31:0] $end
$var wire 32 _ result_op_to_data_mem_skip_mux [31:0] $end
$var wire 5 ` mem_wb_a_rd_to_registers [4:0] $end
$var wire 32 a data_mem_skip_mux_out_to_registers [31:0] $end
$var reg 11 b by_byte_addressing_to_by_word [10:0] $end
$var reg 5 c add_reg_1 [4:0] $end
$var reg 5 d add_reg_2 [4:0] $end
$var reg 5 e ad_reg_rd [4:0] $end
$var reg 7 f op_code [6:0] $end

$scope module PC_MUX $end
$var wire 1 9 SEL $end
$var wire 32 ' IN0 [31:0] $end
$var wire 32 . IN1 [31:0] $end
$var reg 32 g OUT [31:0] $end
$upscope $end


$scope module PC $end
$var reg 32 h OUT [31:0] $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 1 : STALL $end
$var wire 1 i PCWRITE $end
$var wire 32 % IN [31:0] $end
$upscope $end


$scope module INST_MEM $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 11 j read_adr [10:0] $end
$var reg 32 k instruction [31:0] $end
$var integer 32 l i $end
$upscope $end


$scope module PC_ADDER $end
$var wire 32 & A [31:0] $end
$var wire 32 m B [31:0] $end
$var wire 32 ' Q [31:0] $end
$upscope $end


$scope module PIPE_IF_ID $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 1 9 FLUSH $end
$var wire 1 : STALL $end
$var wire 32 & PC_IN [31:0] $end
$var wire 32 ( INSTRUCTION_IN [31:0] $end
$var reg 32 n PC_OUT [31:0] $end
$var reg 32 o INSTRUCTION_OUT [31:0] $end
$upscope $end


$scope module REGISTERS $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 1 ] REGWRITE $end
$var wire 5 p ADR_REG1 [4:0] $end
$var wire 5 q ADR_REG2 [4:0] $end
$var wire 5 ` ADR_WR_REG [4:0] $end
$var wire 32 a WR_DATA [31:0] $end
$var wire 32 * REG_DATA1 [31:0] $end
$var wire 32 + REG_DATA2 [31:0] $end

$scope begin unnamed$$_0 $end
$upscope $end

$upscope $end


$scope module BRANCH_COMPARE $end
$var wire 32 * IN1 [31:0] $end
$var wire 32 + IN2 [31:0] $end
$var reg 1 r OUT $end
$upscope $end


$scope module IMM_ADDER $end
$var wire 32 - A [31:0] $end
$var wire 32 / B [31:0] $end
$var wire 32 . Q [31:0] $end
$upscope $end


$scope module IMM_GEN_SIGN_EXTENDED $end
$var wire 32 ) IN [31:0] $end
$var reg 32 s OUT [31:0] $end
$upscope $end


$scope module CONTROL_UNIT $end
$var wire 32 ) INSTRUCTION [31:0] $end
$var reg 4 t ALUOP [3:0] $end
$var reg 1 u PCSRC $end
$var reg 1 v ALUSRC $end
$var reg 1 w MEMTOREAD $end
$var reg 1 x MEMWRITE $end
$var reg 1 y MEMTOREG $end
$var reg 1 z REGWRITE $end
$var reg 4 { funct7_funct3 [3:0] $end
$upscope $end


$scope module AND_BRANCHING $end
$var wire 1 , A $end
$var wire 1 3 B $end
$var wire 1 9 Q $end
$upscope $end


$scope module STALL_CONTROL_MUX $end
$var wire 1 1 SEL $end
$var wire 9 | IN0 [8:0] $end
$var wire 9 } IN1 [8:0] $end
$var reg 9 ~ OUT [8:0] $end
$upscope $end


$scope module PIPE_ID_EX $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 4 "! ALUOP_IN [3:0] $end
$var wire 1 "" ALUSRC_IN $end
$var wire 1 "# REGWRITE_IN $end
$var wire 1 "$ MEMTOREG_IN $end
$var wire 1 "% MEMWRITE_IN $end
$var wire 1 "& MEMREAD_IN $end
$var wire 5 "' ARS1_IN [4:0] $end
$var wire 5 "( ARS2_IN [4:0] $end
$var wire 5 ") ARD_IN [4:0] $end
$var wire 32 * RS1_IN [31:0] $end
$var wire 32 + RS2_IN [31:0] $end
$var wire 32 / IMMEDIATE_IN [31:0] $end
$var reg 4 "* ALUOP_OUT [3:0] $end
$var reg 1 "+ ALUSRC_OUT $end
$var reg 1 ", REGWRITE_OUT $end
$var reg 1 "- MEMTOREG_OUT $end
$var reg 1 ". MEMWRITE_OUT $end
$var reg 1 "/ MEMREAD_OUT $end
$var reg 5 "0 ARS1_OUT [4:0] $end
$var reg 5 "1 ARS2_OUT [4:0] $end
$var reg 5 "2 ARD_OUT [4:0] $end
$var reg 32 "3 RS1_OUT [31:0] $end
$var reg 32 "4 RS2_OUT [31:0] $end
$var reg 32 "5 IMMEDIATE_OUT [31:0] $end
$upscope $end


$scope module HAZARD_UNIT $end
$var wire 1 E MEMREAD_ID_EX $end
$var wire 1 , BEQ_WRONG_PRED $end
$var wire 5 "6 ARS1_IF_ID [4:0] $end
$var wire 5 "7 ARS2_IF_ID [4:0] $end
$var wire 5 M ARD_ID_EX [4:0] $end
$var wire 7 "8 OP_CODE [6:0] $end
$var reg 1 "9 STALL $end
$var reg 1 ": MUX_SEL $end
$upscope $end


$scope module FORWARD_A_MUX $end
$var wire 2 S SEL [1:0] $end
$var wire 32 I IN0 [31:0] $end
$var wire 32 a IN1 [31:0] $end
$var wire 32 X IN2 [31:0] $end
$var wire 32 "; IN3 [31:0] $end
$var reg 32 "< OUT [31:0] $end
$upscope $end


$scope module FORWARD_B_MUX $end
$var wire 2 T SEL [1:0] $end
$var wire 32 J IN0 [31:0] $end
$var wire 32 a IN1 [31:0] $end
$var wire 32 X IN2 [31:0] $end
$var wire 32 "= IN3 [31:0] $end
$var reg 32 "> OUT [31:0] $end
$upscope $end


$scope module ALUSRC_MUX $end
$var wire 1 D SEL $end
$var wire 32 P IN0 [31:0] $end
$var wire 32 N IN1 [31:0] $end
$var reg 32 "? OUT [31:0] $end
$upscope $end


$scope module ALU $end
$var wire 32 O A [31:0] $end
$var wire 32 Q B [31:0] $end
$var wire 4 C ALU_OPERATION [3:0] $end
$var reg 32 "@ ALU_RESULT [31:0] $end
$upscope $end


$scope module PIPE_EX_MEM $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 1 F MEMWRITE_IN $end
$var wire 1 G MEMTOREG_IN $end
$var wire 1 H REGWRITE_IN $end
$var wire 32 R RESULTOP_IN [31:0] $end
$var wire 32 P WRDATA_IN [31:0] $end
$var wire 5 M ARD_IN [4:0] $end
$var reg 1 "A MEMWRITE_OUT $end
$var reg 1 "B MEMTOREG_OUT $end
$var reg 1 "C REGWRITE_OUT $end
$var reg 32 "D RESULTOP_OUT [31:0] $end
$var reg 32 "E WRDATA_OUT [31:0] $end
$var reg 5 "F ARD_OUT [4:0] $end
$upscope $end


$scope module FORWARDING_UNIT $end
$var wire 5 Z ARD_EX_MEM [4:0] $end
$var wire 5 ` ARD_MEM_WB [4:0] $end
$var wire 5 K ARS1 [4:0] $end
$var wire 5 L ARS2 [4:0] $end
$var wire 1 W REGWRITE_EX_MEM $end
$var wire 1 ] REGWRITE_MEM_WB $end
$var reg 2 "G FORWARD_A [1:0] $end
$var reg 2 "H FORWARD_B [1:0] $end
$upscope $end


$scope module DATA_MEM $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 1 U wrt_en $end
$var wire 11 "I address [10:0] $end
$var wire 32 Y write_data [31:0] $end
$var reg 32 "J read_data [31:0] $end
$var integer 32 "K i $end
$upscope $end


$scope module PIPE_MEM_WB $end
$var wire 1 $ clk $end
$var wire 1 # rst $end
$var wire 1 V MEMTOREG_IN $end
$var wire 1 W REGWRITE_IN $end
$var wire 32 [ MEMDATA_IN [31:0] $end
$var wire 32 X RESULTOP_IN [31:0] $end
$var wire 5 Z ARD_IN [4:0] $end
$var reg 1 "L MEMTOREG_OUT $end
$var reg 1 "M REGWRITE_OUT $end
$var reg 32 "N MEMDATA_OUT [31:0] $end
$var reg 32 "O RESULTOP_OUT [31:0] $end
$var reg 5 "P ARD_OUT [4:0] $end
$upscope $end


$scope module MEM_TO_REG_MUX $end
$var wire 1 \ SEL $end
$var wire 32 _ IN0 [31:0] $end
$var wire 32 ^ IN1 [31:0] $end
$var reg 32 "Q OUT [31:0] $end
$upscope $end

$upscope $end

$upscope $end

$enddefinitions $end

#0
$dumpvars
xv
x""
x"+
xr
0"
x"&
x"/
xw
xy
x"$
x"-
xx
x"%
x".
0":
xu
zi
x"B
x"A
x"C
x"L
x"M
xz
x"#
x",
0!
0"9
x9
x4
x5
x7
x6
x3
x8
xV
xU
xW
z;
0:
xD
xE
xG
xF
xH
x\
x]
x>
x?
xA
x@
xB
x,
0#
01
bxxxxx p
bxxxxx q
bxxxx t
bxxxx "!
bxxxx "*
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "?
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "@
bxxxxx "2
bxxxxx "6
bxxxxx "'
bxxxxx "0
bxxxxx "7
bxxxxx "(
bxxxxx "1
b00000000000000000000000000000100 m
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "K
b00 "G
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "<
b00 "H
b00000000000000000000000000000000 "=
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ">
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "5
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx s
bxxxxxxxxx |
b000000000 }
b00000000000000000000000000000000 ";
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx o
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx k
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "N
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "Q
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx g
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx n
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx h
bxxxxx "F
bxxxxx "P
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "O
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "D
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "3
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "4
bxxxxxxxxx ~
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "E
bxxxxx c
bxxxxx d
bxxxxxxxxxxx "I
bxxxx 0
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx R
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Q
bxxxxxxxxxxx b
bxxxxxxxxx <
bxxxxxxxxx 2
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx [
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx a
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ^
bxxxxx Z
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx X
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Y
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx O
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx P
b00 S
b00 T
bxxxx {
bxxxxx M
bxxxxx K
bxxxxx L
bxxxx C
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx N
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx I
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx J
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx .
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx (
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )
bxxxxx `
bxxxx =
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx '
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx %
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx l
bxxxxxxxxxxx j
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx "J
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx *
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx +
bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx _
bxxxxx e
bxxxxxxx f
bxxxxx ")
bxxxxxxx "8
0$
$end
