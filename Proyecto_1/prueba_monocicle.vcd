$date
	Sun Mar 31 21:33:07 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module z_monocicle_tb $end
$var reg 1 ! CLK $end
$var reg 1 " RST $end
$scope module monocicle_prueba $end
$var wire 1 ! CLK $end
$var wire 1 " RST $end
$var wire 64 # regtomux1 [63:0] $end
$var wire 64 $ regtoALU [63:0] $end
$var wire 64 % mux3toreg [63:0] $end
$var wire 64 & mux2toPC [63:0] $end
$var wire 64 ' mux1toALU [63:0] $end
$var wire 32 ( instruction [31:0] $end
$var wire 64 ) immgentomux1 [63:0] $end
$var wire 1 * decotoreg $end
$var wire 1 + decotomux3 $end
$var wire 1 , decotomux1 $end
$var wire 1 - decotodatamem $end
$var wire 1 . decotoAND $end
$var wire 4 / decotoALU [3:0] $end
$var wire 64 0 data_memtomux3 [63:0] $end
$var wire 64 1 adder2tomux2 [63:0] $end
$var wire 64 2 adder1tomux2 [63:0] $end
$var wire 64 3 PCtoInst_mem [63:0] $end
$var wire 1 4 ANDtomux2 $end
$var wire 64 5 ALUtodata_mem [63:0] $end
$var wire 1 6 ALUtoAND $end
$scope module ALU_mono $end
$var wire 64 7 B [63:0] $end
$var wire 4 8 ALU_operation [3:0] $end
$var wire 64 9 A [63:0] $end
$var reg 64 : ALU_result [63:0] $end
$var reg 1 6 zero $end
$upscope $end
$scope module PC_mono $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 64 ; IN [63:0] $end
$var reg 64 < OUT [63:0] $end
$upscope $end
$scope module adder1 $end
$var wire 64 = A [63:0] $end
$var wire 64 > B [63:0] $end
$var wire 64 ? Q [63:0] $end
$upscope $end
$scope module adder2 $end
$var wire 64 @ A [63:0] $end
$var wire 64 A Q [63:0] $end
$var wire 64 B B [63:0] $end
$upscope $end
$scope module control_mono $end
$var wire 11 C instruction [10:0] $end
$var parameter 7 D arit_op $end
$var parameter 7 E beq_op $end
$var parameter 7 F lw_op $end
$var parameter 7 G sw_op $end
$var reg 4 H ALUOp [3:0] $end
$var reg 1 , ALUSrc $end
$var reg 1 . Branch $end
$var reg 1 - MemWrite $end
$var reg 1 + MemtoReg $end
$var reg 1 * RegWrite $end
$upscope $end
$scope module data_mono $end
$var wire 64 I address [63:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 - wrt_en $end
$var wire 64 J write_data [63:0] $end
$var reg 64 K read_data [63:0] $end
$var integer 32 L i [31:0] $end
$upscope $end
$scope module gate $end
$var wire 1 . a $end
$var wire 1 6 b $end
$var wire 1 4 q $end
$upscope $end
$scope module inst_mono $end
$var wire 1 ! clk $end
$var wire 64 M read_adr [63:0] $end
$var wire 1 " rst $end
$var reg 32 N instruction [31:0] $end
$var integer 32 O i [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 1 , SEL $end
$var wire 64 P IN1 [63:0] $end
$var wire 64 Q IN0 [63:0] $end
$var reg 64 R OUT [63:0] $end
$upscope $end
$scope module mux2 $end
$var wire 64 S IN0 [63:0] $end
$var wire 64 T IN1 [63:0] $end
$var wire 1 4 SEL $end
$var reg 64 U OUT [63:0] $end
$upscope $end
$scope module mux3 $end
$var wire 64 V IN0 [63:0] $end
$var wire 64 W IN1 [63:0] $end
$var wire 1 + SEL $end
$var reg 64 X OUT [63:0] $end
$upscope $end
$scope module register_mono $end
$var wire 5 Y adr_reg1 [4:0] $end
$var wire 5 Z adr_reg2 [4:0] $end
$var wire 5 [ adr_wr_reg [4:0] $end
$var wire 1 ! clk $end
$var wire 1 * regwrite $end
$var wire 1 " rst $end
$var wire 64 \ wr_data [63:0] $end
$var wire 64 ] reg_data2 [63:0] $end
$var wire 64 ^ reg_data1 [63:0] $end
$var integer 32 _ i [31:0] $end
$upscope $end
$scope module signextend_mono $end
$var wire 32 ` IN [31:0] $end
$var reg 64 a OUT [63:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 b i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100011 G
b11 F
b1100011 E
b110011 D
$end
#0
$dumpvars
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx C
bx B
bx A
bx @
bx ?
b100 >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
x6
bx 5
x4
bx 3
bx 2
bx 1
bx 0
bx /
x.
x-
x,
x+
x*
bx )
bx (
bx '
bx &
bx %
bx $
bx #
0"
0!
$end
#1000
04
b0 0
b0 K
b0 W
b110111 %
b110111 X
b110111 \
b100 &
b100 ;
b100 U
b10 /
b10 8
b10 H
0.
0+
0-
0,
1*
b100001 '
b100001 7
b100001 R
06
b110111 5
b110111 :
b110111 I
b110111 V
b1111111111111111111111111111111111111111111111111111111111111111 1
b1111111111111111111111111111111111111111111111111111111111111111 A
b1111111111111111111111111111111111111111111111111111111111111111 T
b1111111111111111111111111111111111111111111111111111111111111111 )
b1111111111111111111111111111111111111111111111111111111111111111 B
b1111111111111111111111111111111111111111111111111111111111111111 P
b1111111111111111111111111111111111111111111111111111111111111111 a
b110011 C
b1000 [
b100001 #
b100001 J
b100001 Q
b100001 ]
b0 Z
b10110 $
b10110 9
b10110 ^
b1000 Y
b1000000010000110011 (
b1000000010000110011 N
b1000000010000110011 `
1"
b1000000 L
b1000000 _
b1000000 O
b100 2
b100 ?
b100 S
b0 3
b0 <
b0 =
b0 @
b0 M
1!
#2000
b0 b
0!
#3000
06
b0 0
b0 K
b0 W
b100001 %
b100001 X
b100001 \
b0 /
b0 8
b0 H
b110111 '
b110111 7
b110111 R
b100001 5
b100001 :
b100001 I
b100001 V
b1110110011 C
b110111 #
b110111 J
b110111 Q
b110111 ]
b1000 Z
b100001 $
b100001 9
b100001 ^
b0 Y
b1000 &
b1000 ;
b1000 U
b100000000111010000110011 (
b100000000111010000110011 N
b100000000111010000110011 `
b1000 2
b1000 ?
b1000 S
b11 1
b11 A
b11 T
b100 3
b100 <
b100 =
b100 @
b100 M
1!
#4000
0!
b1 b
#5000
b100001 '
b100001 7
b100001 R
b100001 #
b100001 J
b100001 Q
b100001 ]
b0 0
b0 K
b0 W
b101011 %
b101011 X
b101011 \
b1 /
b1 8
b1 H
b101011 5
b101011 :
b101011 I
b101011 V
b1100110011 C
b10000 [
b1011 $
b1011 9
b1011 ^
b10000 Y
b1100 &
b1100 ;
b1100 U
b100010000110100000110011 (
b100010000110100000110011 N
b100010000110100000110011 `
b1100 2
b1100 ?
b1100 S
b111 1
b111 A
b111 T
b1000 3
b1000 <
b1000 =
b1000 @
b1000 M
1!
#6000
0!
b10 b
#7000
14
16
b0 %
b0 X
b0 \
b110 /
b110 8
b110 H
1.
0*
b0 5
b0 :
b0 I
b0 V
b0 )
b0 B
b0 P
b0 a
b1100011 C
b0 [
b0 Z
b100001 $
b100001 9
b100001 ^
b0 Y
b1100 &
b1100 ;
b1100 U
b1100011 (
b1100011 N
b1100011 `
b10000 2
b10000 ?
b10000 S
b1100 1
b1100 A
b1100 T
b1100 3
b1100 <
b1100 =
b1100 @
b1100 M
1!
#8000
0!
b11 b
#9000
1!
#10000
0!
b100 b
#11000
1!
#12000
0!
b101 b
